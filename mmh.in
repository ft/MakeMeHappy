#!@@PYTHON@@

import argparse
import os
import re
import sys

import makemehappy.build as build
import makemehappy.utilities as mmh
import makemehappy.system as ms
import makemehappy.toplevel as top

from logbook import Logger
from makemehappy.buildroot import BuildRoot
from makemehappy.cut import CodeUnderTest
from makemehappy.yamlstack import ConfigStack, SourceStack
from makemehappy.loghandler import MMHLogHandler

version = "@@VERSION@@"
fullname = "MakeMeHappy"
name = "mmh"
commandReturnValue = 0

log = Logger(fullname)
log.handlers.append(MMHLogHandler())

etcdir = '@@ETCDIR@@'
datadir = '@@DATADIR@@'

cfg = ConfigStack(log, 'Configuration',
                  mmh.dotFile('config.yaml'),
                  mmh.xdgFile('config.yaml'),
                  os.path.join(etcdir,  'config.yaml'),
                  os.path.join(datadir, 'config.yaml'))

src = SourceStack(log, 'Source Definition',
                  mmh.dotFile('sources.yaml'),
                  mmh.xdgFile('sources.yaml'),
                  os.path.join(etcdir,  'sources.yaml'),
                  os.path.join(datadir, 'sources.yaml'))

cmakeParameters = None
cmakeSeparator = None
try:
    cmakeSeparator = sys.argv.index('++')
    if (cmakeSeparator == len(sys.argv)):
        cmakeParameters = []
    else:
        cmakeParameters = sys.argv[cmakeSeparator+1:]
    sys.argv = sys.argv[0:cmakeSeparator]
except ValueError:
    cmakeParameters = None

ap = argparse.ArgumentParser()

### Top Level Options

ap.add_argument(
    "-d", "--directory", default = None,
    help = "specify the build-root directory")

ap.add_argument(
    "-m", "--module", default = "module.yaml",
    help = "specify the file that contains the"
         + " module description (defaults to module.yaml)")

ap.add_argument(
    "-p", "--preserve", action = "store_true",
    help = "preserve build root instead of deleting it."
         + " In combination with -d, delete build root"
         + " before termination.")

ap.add_argument(
    "-q", "--quiet", action = "store_true",
    help = "Disable informational output")

ap.add_argument(
    "-P", "--show-phases", action = "store_true",
    help = "Show build phases even with --log-to-file.")

ap.add_argument(
    "-L", "--log-all", action = "store_true",
    help = "send all output to logging facility")

ap.add_argument(
    "-l", "--log-to-file", action = "store_true",
    help = "log output to file (implies --log-all)")

ap.add_argument(
    "-f", "--log-file", default = None,
    help = "specify log-file name to use")

ap.add_argument(
    "-T", "--toolchains", default = None,
    help = "select toolchains to include in build")

ap.add_argument(
    "-B", "--buildtools", default = None,
    help = "select buildtools to include in build")

ap.add_argument(
    "-C", "--buildconfigs", default = None,
    help = "select build configurations to include in build")

ap.add_argument(
    "-A", "--architectures", default = None,
    help = "select architectures to include in build")

ap.add_argument(
    "-Q", "--query", default = None,
    help = "query aspects about the program")

ap.add_argument(
    "-s", "--source", default = [], action = "append",
    help = "add a module source definition")

ap.add_argument(
    "-S", "--succeed", action = "store_true",
    help = "force successful termination")

ap.add_argument(
    "-F", "--force", action = "store_true",
    help = "force using MakeMeHappy.yaml")

ap.add_argument(
    "-V", "--version", action = "store_true",
    help = "show program version")

ap.add_argument(
    "-v", "--verbose", action = "store_true",
    help = "produce verbose output")

### Top-Level Commands

subp = ap.add_subparsers(
    dest = 'sub_command', metavar = 'Sub Commands')

# build
ap_build = subp.add_parser('build', help = 'Build a module')

# init
ap_init = subp.add_parser(
    'build-tree-init', aliases = [ 'init' ],
    help = 'Build a module')

ap_init.set_defaults(sub_command = 'build-tree-init')

# download
ap_download = subp.add_parser(
    'download-source', aliases = [ 'get' ],
    help = 'Download sources for a module')

ap_download.set_defaults(sub_command = 'download-source')
ap_download.add_argument('modules', nargs = '+')

# download-sources
ap_sources = subp.add_parser(
    'download-sources',
    help = 'Download sources for ALL module')

ap_sources.add_argument('destination', nargs = '?', default = '.')

# dump-description
ap_dump = subp.add_parser(
    'dump-description', aliases = [ 'dump' ],
    help = 'Show parsed instruction file data')

ap_dump.set_defaults(sub_command = 'dump-description')

# fetch-dependencies
ap_fetch = subp.add_parser(
    'fetch-dependencies', aliases = [ 'deps' ],
    help = 'Download dependencies of a module')

ap_fetch.set_defaults(sub_command = 'fetch-dependencies')

# generate-toplevel
ap_top = subp.add_parser(
    'generate-toplevel', aliases = [ 'top' ],
    help = 'Generate toplevel of module build-tree')

ap_top.set_defaults(sub_command = 'generate-toplevel')

# reset-setup
ap_reset = subp.add_parser(
    'reset-setup', aliases = [ 'reset' ],
    help = 'Reset build-tree meta-data')

ap_reset.set_defaults(sub_command = 'reset-setup')

# run-instance
ap_run = subp.add_parser(
    'run-instance', aliases = [ 'run' ],
    help = '(Re)run previously configured build-tree')

ap_run.set_defaults(sub_command = 'run-instance')
ap_run.add_argument('instances', nargs = '*')

# show-result
ap_result = subp.add_parser(
    'show-result', aliases = [ 'result' ],
    help = 'Show result table from log-file')

ap_result.set_defaults(sub_command = 'show-result')
ap_result.add_argument(
    "-f", "--full", action = "store_true",
    dest = 'full_result',
    help = "Replay full log with log-prefix stripped.")
ap_result.add_argument(
    "-q", "--quiet", action = "store_true",
    dest = 'quiet_result',
    help = "Do not show and result output.")
ap_result.add_argument(
    "-s", "--short", action = "store_true",
    dest = 'short_result',
    help = "Only show final short-form result.")
ap_result.add_argument('file', nargs = 1)

# show-source
ap_show = subp.add_parser(
    'show-source', aliases = [ 'show' ],
    help = 'Show source location for module(s)')

ap_show.set_defaults(sub_command = 'show-source')
ap_show.add_argument('modules', nargs = '*')

# system
ap_system = subp.add_parser(
    'system', help = 'Handle building production systems')

ap_system.set_defaults(sub_command = 'system')
ap_system.add_argument(
    "-s", "--single-instance", action = "store_true",
    help = "Build a single instance in the build directory root")
ap_system.add_argument(
    "-a", "--all-instances", action = "store_true",
    help = "Force building all system instances")


### System Commands

sub_system = ap_system.add_subparsers(
    dest = 'system', metavar = 'System Commands')

# list
sys_list = sub_system.add_parser(
    'list', help = 'List all specified build instances')

# db
sys_db = sub_system.add_parser(
    'db', help = 'Link compile command db to system root')

sys_db.add_argument(
    "-l", "--location", default = '.',
    help = "specify the build-root directory")
sys_db.add_argument('instances', default = [ ], nargs = '*')

# build
sys_build = sub_system.add_parser(
    'build', help = 'Build all or specified build instances')

sys_build.add_argument('instances', default = [ ], nargs = '*')

# rebuild
sys_rebuild = sub_system.add_parser(
    'rebuild', help = 'Rebuild all or specified build instances')

sys_rebuild.add_argument('instances', default = [ ], nargs = '*')

# clean
sys_clean = sub_system.add_parser(
    'clean', help = 'Clean all or specified build instances')

sys_clean.add_argument('instances', default = [ ], nargs = '*')

### End of Argument Parser Spec


cmdargs = ap.parse_args()
#print(cmdargs)
#print(cmdargs.sub_command)

def mmh_exit(code):
    if cmdargs.succeed:
        exit(0)
    exit(code)

if cmdargs.query is not None:
    cfg.load()
    cut = CodeUnderTest(log, cfg, cmdargs, src, cmdargs.module)
    if (os.path.isfile(cmdargs.module) == True):
        cut.loadModule()
    q = cmdargs.query
    result = []
    if (q == 'toolchains'):
        result = cut.allToolchains()
    elif (q == 'architectures'):
        result = cut.allArchitectures()
    elif (q == 'buildtools'):
        result = cut.allBuildtools()
    elif (q == 'buildconfigs'):
        result = cut.allBuildConfigs()
    else:
        mmh.warn('Unknown query: {}'.format(q))
        mmh_exit(1)
    print(" ".join(result))
    mmh_exit(0)

if (isinstance(cmdargs.directory, str)):
    cmdargs.preserve = not(cmdargs.preserve)

if (cmdargs.verbose):
    mmh.setVerbosity(1)

if (cmdargs.quiet):
    log.disable()

if ('single_instance' not in cmdargs):
    cmdargs.single_instance = None

if ('all_instances' not in cmdargs):
    cmdargs.all_instances = False

if (cmdargs.version):
    print("{} ({}) version {}".format(fullname, name, version))
    print()
    print('  datadir = {}'.format(datadir))
    print('  etcdir  = {}'.format(etcdir))
    print()
    mmh_exit(0)

for item in cmdargs.source:
    if (os.path.isfile(item) == False):
        mmh.warn("Source definition does not exist: {}".format(item))
        mmh_exit(1)
    src.push(item)

if cmdargs.log_to_file:
    cmdargs.log_all = True
    if cmdargs.log_file is not None:
        log.handlers[0].setFile(cmdargs.log_file)
else:
    log.handlers[0].setFile(False)

if cmdargs.toolchains is not None:
    cmdargs.toolchains = cmdargs.toolchains.split(',')
if cmdargs.buildtools is not None:
    cmdargs.buildtools = cmdargs.buildtools.split(',')
if cmdargs.buildconfigs is not None:
    cmdargs.buildconfigs = cmdargs.buildconfigs.split(',')
if cmdargs.architectures is not None:
    cmdargs.architectures = cmdargs.architectures.split(',')

cmdargs.cmake = cmakeParameters

if (cmdargs.sub_command == None):
    if (os.path.isfile('system.yaml')):
        cmdargs.sub_command = 'system'
    else:
        cmdargs.sub_command = 'build'
    log.info("Starting up using default command ({})".format(cmdargs.sub_command))
elif (cmdargs.sub_command != False):
    log.info("Starting up using '{}' command".format(cmdargs.sub_command))

cmdargs.fromyaml = False
if (cmdargs.sub_command != 'reset-setup' and
    cmdargs.sub_command != 'system'      and
    cmdargs.directory != None            and
    mmh.noParameters(cmdargs)):
    fn = os.path.join(cmdargs.directory, 'MakeMeHappy.yaml')
    if (os.path.exists(fn)):
        data = mmh.load(fn)
        if (cmdargs.force == True):
            data['version'] = version
            mmh.dump(fn, data)
        cmdargs.fromyaml = True
        if (mmh.matchingVersion(version, data)):
            if ('parameters' in data):
                p = data['parameters']
                log.info('Loading parameters from {}'.format(fn))
                if 'architectures' in p:
                    cmdargs.architectures = p['architectures']
                if 'buildconfigs' in p:
                    cmdargs.buildconfigs = p['buildconfigs']
                if 'buildtools' in p:
                    cmdargs.buildtools = p['buildtools']
                if 'toolchains' in p:
                    cmdargs.toolchains = p['toolchains']
                if 'cmake' in p:
                    cmdargs.cmake = p['cmake']
            if ('cmake' in data):
                p = data['cmake']
                log.info('Loading cmake-information from {}'.format(fn))
                if 'module-path' in p:
                    cmdargs.modulePath = p['module-path']
                if 'toolchain-path' in p:
                    cmdargs.toolchainPath = p['toolchain-path']
            if ('zephyr' in data):
                p = data['zephyr']
                log.info('Loading zephyr-information from {}'.format(fn))
                if 'board-root' in p:
                    cmdargs.boardRoot = p['board-root']
                if 'dts-root' in p:
                    cmdargs.dtsRoot = p['dts-root']
                if 'soc-root' in p:
                    cmdargs.socRoot = p['soc-root']
        else:
            fv = None
            if (not data is None and 'version' in data):
                fv = data['version']
            log.error("{}: Version mismatch: {} != {}".format(fn, version, fv))
            log.error("If suitable ‘--force’ to force using the file!")
            mmh_exit(1)

def adjustConfig(cfg, args):
    layer = {}
    adjustments = 0
    if args.log_all == True:
        layer['log-all'] = not(cfg.lookup('log-all'))
        adjustments = adjustments + 1
    if args.log_to_file == True:
        layer['log-to-file'] = not(cfg.lookup('log-to-file'))
        adjustments = adjustments + 1
    if adjustments > 0:
        cfg.pushLayer(layer)

def requireModuleDefinition(args):
    if (os.path.isfile(args.module) == False):
        mmh.warn("Module definition does not exist: {}".format(args.module))
        mmh_exit(1)

if (cmdargs.sub_command == "build-tree-init"):
    requireModuleDefinition(cmdargs)
    cfg.load()
    adjustConfig(cfg, cmdargs)
    cut = CodeUnderTest(log, cfg, cmdargs, src, cmdargs.module)
    cut.initRoot(version, cmdargs)
    cut.populateRoot()
    cut.linkIntoRoot()

elif (cmdargs.sub_command == "fetch-dependencies"):
    requireModuleDefinition(cmdargs)
    cfg.load()
    adjustConfig(cfg, cmdargs)
    cut = CodeUnderTest(log, cfg, cmdargs, src, cmdargs.module)
    cut.initRoot(version, cmdargs)
    cut.loadModule()
    cut.cliAdjust(toolchains    = cmdargs.toolchains,
                  architectures = cmdargs.architectures,
                  buildconfigs  = cmdargs.buildconfigs,
                  buildtools    = cmdargs.buildtools)
    cut.loadSources()
    cut.changeToRoot()
    cut.loadDependencies()

elif (cmdargs.sub_command == "generate-toplevel"):
    requireModuleDefinition(cmdargs)
    cfg.load()
    adjustConfig(cfg, cmdargs)
    cut = CodeUnderTest(log, cfg, cmdargs, src, cmdargs.module)
    cut.initRoot(version, cmdargs)
    cut.loadModule()
    cut.cliAdjust(toolchains    = cmdargs.toolchains,
                  architectures = cmdargs.architectures,
                  buildconfigs  = cmdargs.buildconfigs,
                  buildtools    = cmdargs.buildtools)
    cut.loadSources()
    cut.changeToRoot()
    cut.loadDependencies()
    cut.cmakeIntoYAML()
    cut.generateToplevel()

elif (cmdargs.sub_command == "reset-setup"):
    if (cmdargs.directory == None):
        print("reset-argument only works with -d!")
        mmh_exit(1)

    fn = os.path.join(cmdargs.directory, 'MakeMeHappy.yaml')
    data = { 'version': version }
    mmh.dump(fn, data)

elif (cmdargs.sub_command == "run-instance"):
    if (len(cmdargs.instances) >= 1):
        cfg.load()
        for d in cmdargs.instances:
            build.runInstance(cfg, log, cmdargs, d)
        mmh_exit(0)

    requireModuleDefinition(cmdargs)
    cfg.load()
    adjustConfig(cfg, cmdargs)
    cut = CodeUnderTest(log, cfg, cmdargs, src, cmdargs.module)
    cut.initRoot(version, cmdargs)
    cut.loadModule()
    cut.cliAdjust(toolchains    = cmdargs.toolchains,
                  architectures = cmdargs.architectures,
                  buildconfigs  = cmdargs.buildconfigs,
                  buildtools    = cmdargs.buildtools)
    cut.loadSources()
    cut.changeToRoot()
    cut.loadDependencies()
    cut.cmakeIntoYAML()
    cut.build()

    cut.renderStatistics()
    if cut.wasSuccessful():
        log.info('All {} builds succeeded.'.format(cut.countBuilds()))
    else:
        log.info('{} build(s) out of {} failed.'
                 .format(cut.countFailed(), cut.countBuilds()))
        commandReturnValue = 1

elif (cmdargs.sub_command == "build"):
    requireModuleDefinition(cmdargs)

    cfg.load()
    adjustConfig(cfg, cmdargs)
    cut = CodeUnderTest(log, cfg, cmdargs, src, cmdargs.module)
    cut.loadModule()
    cut.cliAdjust(toolchains    = cmdargs.toolchains,
                  architectures = cmdargs.architectures,
                  buildconfigs  = cmdargs.buildconfigs,
                  buildtools    = cmdargs.buildtools)
    cut.loadSources()
    cut.initRoot(version, cmdargs)
    if cmdargs.log_to_file is True and cmdargs.log_file is None:
        fn = cut.root.name() + '.log'
        print('Logging to: {}'.format(fn))
        log.handlers[0].setFile(fn)
    cut.populateRoot()
    cut.linkIntoRoot()
    cut.changeToRoot()
    cut.loadDependencies()
    cut.cmakeIntoYAML()
    cut.generateToplevel()
    cut.build()

    if (cmdargs.preserve == False):
        cut.cleanupRoot()

    cut.renderStatistics()
    if cut.wasSuccessful():
        log.info('All {} builds succeeded.'.format(cut.countBuilds()))
    else:
        log.info('{} build(s) out of {} failed.'
                 .format(cut.countFailed(), cut.countBuilds()))
        commandReturnValue = 1

elif (cmdargs.sub_command == "dump-description"):
    data = mmh.load(cmdargs.module)
    mmh.pp(data)

elif (cmdargs.sub_command == "show-result"):
    input = cmdargs.file[0]
    table = []
    marker = re.compile(
        r'\[\d+-\d+-\d+\s+\d+:\d+:\d+.\d+\]\s+[A-Z]+:\s+MakeMeHappy:\s+Build\s+Summary:$')
    strip = re.compile(
        r'\[\d+-\d+-\d+\s+\d+:\d+:\d+.\d+\]\s+[A-Z]+:\s+MakeMeHappy:\s')
    success = re.compile(r'All \d+ builds succeeded.')
    for line in open(input):
        if (re.match(marker, line)):
            entry = re.sub(strip, '', line)
            table = [ entry ]
        elif (len(table) > 0):
            entry = re.sub(strip, '', line)
            table += [ entry ]
        if (cmdargs.full_result and len(table) == 0):
            stripped = re.sub(strip, '', line)
            print(stripped, end='')

    if (cmdargs.quiet_result == False):
        if (cmdargs.short_result == False):
            for line in table:
                print(line, end='')
        else:
            print(table[-1], end='')

    if (len(table) > 0):
        final = table[-1]
        if (re.match(success, final)):
            commandReturnValue = 0
        else:
            commandReturnValue = 1
    else:
        if (cmdargs.quiet_result == False):
            print('Could not find result table in log: {}'.format(input))
        commandReturnValue = 1

elif (cmdargs.sub_command == "show-source"):
    src.load()
    names = cmdargs.modules
    if (len(names) == 0):
        names = src.allSources();

    for name in names:
        data = src.lookup(name)
        print("{}: ".format(name), end='')
        print(data)

elif (cmdargs.sub_command == "download-source"):
    cfg.load()
    src.load()

    for module in cmdargs.modules:
        meta = src.lookup(module)
        source = meta['repository']
        mmh.loggedProcess(cfg, log, ['git', 'clone', source, module])

elif (cmdargs.sub_command == "download-sources"):
    destination = cmdargs.destination
    cfg.load()
    src.load()
    loaded = {}
    failed = {}
    for source in src.data:
        if not('modules' in source):
            continue
        for module in source['modules']:
            if (module in loaded):
                log.info("Module {} already defined by {}",
                         module, loaded[module]['source'])
                continue
            sf = os.path.join(source['root'], source['definition'])
            dd = os.path.join(destination, module)
            repo = source['modules'][module]['repository']
            log.info("Downloading module {} from {}...", module, repo)
            rc = mmh.loggedProcess(cfg, log, ['git', 'clone', repo, dd])
            if (rc == 0):
                log.info("Downloading module {} was successful.", module)
            else:
                log.error("Downloading module {} failed!", module)
                failed[module] = {'source': sf, 'repository': repo }
            loaded[module] = {'source': sf, 'repository': repo }
    for mod in sorted(loaded):
        log.info("  Success: {} from {} [{}]",
                 mod,
                 loaded[mod]['repository'],
                 loaded[mod]['source'])
    if (len(failed) == 0):
        log.info("Downloading ALL sources succeeded!")
    else:
        log.error("Downloading {} of {} sources failed!",
                  len(failed), len(loaded))
        commandReturnValue = 1
        for fail in sorted(failed):
            log.error("  Failure: {} from {} [{}]",
                      fail,
                      failed[fail]['repository'],
                      failed[fail]['source'])

elif (cmdargs.sub_command == "system"):
    if ((not 'system' in cmdargs) or (cmdargs.system == None)):
        cmdargs.system = 'build'

    if (cmdargs.directory == None):
        cmdargs.directory = 'build'

    if (not 'instances' in cmdargs):
        cmdargs.instances = [ ]

    cfg.load()
    adjustConfig(cfg, cmdargs)
    try:
        system = ms.System(log, version, cfg, cmdargs);
        if cmdargs.log_to_file is True and cmdargs.log_file is None:
            fn = system.buildRoot() + '.log'
            print('Logging to: {}'.format(fn))
            log.handlers[0].setFile(fn)
        system.load()

        if (cmdargs.system == 'build'):
            system.build()
        elif (cmdargs.system == 'rebuild'):
            system.rebuild()
        elif (cmdargs.system == 'clean'):
            system.clean()
        elif (cmdargs.system == 'list'):
            system.listInstances()
        elif (cmdargs.system == 'db'):
            system.makeDBLink()
    except Exception:
        commandReturnValue = 1

elif (isinstance(cmdargs.sub_command, str)):
    print("Not implemented yet: {}".format(cmdargs.sub_command))

else:
    mmh.warn("This should not happen. {}".format(cmdargs))
    mmh_exit(1)

mmh_exit(commandReturnValue)
